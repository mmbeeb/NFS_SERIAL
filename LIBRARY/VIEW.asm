

	;********************************
	;*            VIEW              *
	;* Update by Martin Mather 2022 *
	;********************************

	;* Assembled using beebasm 1.09 *
	
	;THIS MODIFIED VERSION IS BASED ON THE MASTER VERSION.
	
	;RATHER THAN PEEKING THE WHOLE SCREEN IN ONE GO
	;IT IS PEEKED IN 256 BYTE BLOCKS.
	
	;OTHER MODS ARE MAINLY TO MAKE THE FILE SMALLER
	;SO IT CAN BE RUN AT &0E10 (IN THE STATIC WORKSPACE [OWNED BY THE NFS])

	LOADADDR1=?&0E10

	GSINIT=?&FFC2
	GSREAD=?&FFC5
	OSARGS=?&FFDA
	OSASCI=?&FFE3
	OSNEWL=?&FFE7
	OSWRCH=?&FFEE
	OSWORD=?&FFF1
	OSBYTE=?&FFF4

	TXTPTR=?&F2

	CLEAR LOADADDR1, LOADADDR1+&200
	ORG LOADADDR1

.VIEW_START
{
	USERID_SIZE=10;MAXIMUM SIZE OF FILE SERVER USER ID


.SCRN_INFO

	;STATION NUMBER?
	JSR S_DEB7
	BCC L_DD3C;IF READ, A=STATION, X=NET


	;USER NAME?
	;SLIGHT CHANGE HERE TO PREVENT BUFFER OVERFLOW
	LDX #&100-USERID_SIZE-2

.L_DD09
	INX
	BNE L_DD14;BUFFER NOT FULL

	JMP L_DE3F_SYNTAX

IF LOADADDR1=&0E10
	ORG &0E22;BYTES 0E1E-0E21 GET OVERWRITTEN BY THE NFS
ENDIF

.L_DD14
	LDA (TXTPTR),Y
	CMP #' '+1
	BCS L_DD18;IF A > ' '

	LDA #&0D

.L_DD18
	STA FS_BLK+7-&100+USERID_SIZE+1,X
	INY
	EOR #&0D
	BNE L_DD09
	
	;GET STATION & NET FROM FILE SERVER
	LDX #LO(FS_BLK)
	LDY #HI(FS_BLK)
	LDA #&14
	JSR OSWORD

	LDA FS_BLK+3
	BEQ L_DD36;USER FOUND

	;REPORT ERROR RETURNED BY FILE SERVER, I.E. "Not logged on"
	LDA #0
	STA FS_BLK+17;TERMINATE MESSAGE
	JMP FS_BLK+2

.L_DD36
	LDA FS_BLK+5;STATION
	LDX FS_BLK+6;NET
	

	;GOT STATION & NET
.L_DD3C
	STA PEEK_BLK+2
	STX PEEK_BLK+3


	;TRANSMIT REQUEST FOR OS PROCEDURE 2
	;This instructs the remote machine to copy data relating to the screen mode to it's
	;second page of private workspace, offset at &E9 (see below).
	JSR TRANSMIT


	;In the remote machine the pointer to the second page of private workspace is at &009E	
	;SETUP PEEK OF POINTER
	LDA #&81
	STA PEEK_BLK;PEEK
	LDA #&9E
	STA PEEK_BLK+12;REMOTE LOCATION

.L_DD46
	JSR TRANSMIT
	LDA PEEK_BLK+12
	BNE L_DD46;DATA RETURNED?

	
	;SETUP PEEK TO SCRN_INFO BUFFER
	;Read the remote data that was copied to the private workspace:
	;(Decimal offset from SCRN_INFO)
	; 0 Address of top left corner of screen (as sent to 6845)
	; 2 Physical colour of logical colour 0
	;   ... etc ...
	;17 Physical colour of logical colour 15
	;18 Mode
	;19 Bottom of display (as OSBYTE &85)
	;21 Mark period count (flashing colours)
	;22 Space period count (flashing colours)
	
	LDA #HI(SCRN_INFO)
	STA PEEK_BLK+5
	STA PEEK_BLK+9
	
	LDA #LO(SCRN_INFO)
	STA PEEK_BLK+4
	LDA #LO(SCRN_INFO+23)
	STA PEEK_BLK+8
	LDA #&E9
	STA PEEK_BLK+12
	
	JSR TRANSMIT

	LDA #&10	
	BIT SCRN_INFO+18;REMOTE SCREEN MODE
	BVS L_DD7D;BIT 6 SET?

	;TEST ?&D0 IN REMOTE MACHINE
	;VDU STATUS BYTE (AS OSBYTE &75)
	;BIT 4?
	;NOT USED ON MODEL B
	;B+ & MASTER = SHADOW SCREEN SELECTED

	BIT PEEK_BLK+62
	BEQ L_DD8C

	BRK
	EQUS &AD, "Mode ?", 0

.L_DD7D
	DEC PEEK_BLK+14;&FE

.L_DD8C
	LDA SCRN_INFO+18
	ORA #&80
	TAX
	LDA #22
	JSR S_DE64;VDU 22,X, i.e. MODE X
	
	AND #&07
	CMP #7
	PHP

	
	;SET UP PEEK CONTROL BLOCK TO READ SCREEN DATA
	
	TAX
	LDY SCRN_START,X
	STY PEEK_BLK+5
	INY
	STY PEEK_BLK+9

	LDX #0
	STX PEEK_BLK+4
	STX PEEK_BLK+8
	DEC PEEK_BLK+6;&FE
	DEC PEEK_BLK+10;&FE
	

	;SET UP SCREEN, LOGICAL COLOURS ETC., TO MATCH REMOTE
	
	INX;X:=1

.L_DDB4
	LDA SCRN_INFO+19,X
	STA PEEK_BLK+12,X;BOTTOM OF DISPLAY RAM
	
	LDA SCRN_INFO,X;ADDRESS OF TOP LEFT OF REMOTE SCREEN
	STA &0350,X
	STA &B2,X
	
	DEX
	BPL L_DDB4

	LDY #&02
	LDA &0351
	
	PLP
	BEQ L_DDD5;IF MODE 7

.L_DDCD
	LSR A
	ROR &B2
	DEY
	BPL L_DDCD
	BNE L_DDD9

.L_DDD5
	SBC #&74
	EOR #&20

.L_DDD9
	LDY #&0C
	STY &FE00
	INY;Y:=&0D
	STA &FE01
	STY &FE00
	LDA &B2
	STA &FE01
	
	;DEFINE LOGICAL COLOURS
	LDX #&0F

IF LOADADDR1=&0E10
	BNE L_DDEC
	
	ORG &0F09
	EQUD &FFFF0E10;Execution address
ENDIF

.L_DDEC
	JSR S_DE62;VDU 19,X
	LDA SCRN_INFO+2,X;PHYSICAL COLOUR OF LOGICAL COLOUR X
	JSR OSWRCH

	;VDU 0,0,0
	LDY #&03

.L_DDF7
	JSR OSWRCH
	DEY
	BNE L_DDF7
	
	DEX
	BPL L_DDEC
	
	LDX SCRN_INFO+21;MARK PERIOD COUNT (FLASHING COLOURS)
	STX &0252
	LDX SCRN_INFO+22;SPACE PERIOD COUNT (FLASHING COLOURS)
	STX &0253
	
	LDA #&0D
	JSR OSWRCH
	

	;DO SCREEN PEEK, RETRY ON FAILURE
.loop
	JSR TRANSMIT
	INC PEEK_BLK+13
	INC PEEK_BLK+9
	INC PEEK_BLK+5
	BPL loop;<&80
	
	RTS
	
	;TRANSMIT & POLL
.TRANSMIT
	DEC L_DE3F_SYNTAX;USED AS COUNTER
	BEQ L_DE30_NOTLISTENING;GIVE UP?

	LDX #LO(PEEK_BLK)
	LDY #HI(PEEK_BLK)
	LDA #&10
	JSR OSWORD;TRANSMIT

	;POLLING LOOP (WITH ESCAPE)
.L_DE1F
	BIT &FF
	BPL L_DE6B;NO ESCAPE!

	LDA #&7E
	JSR OSBYTE
	
	BRK
	EQUS &11, "Escape"

.L_DE30_NOTLISTENING
	BRK
	EQUS &A2, "Not listening"

.L_DE3F_SYNTAX
	BRK
IF LOADADDR1=&0E10
	EQUS &DE, "Syntax ?", 0
ELSE
	EQUS &DE, "Syntax : *View <Station>|<User>", 0
ENDIF
	
.SCRN_START
	EQUB &30, &30, &30, &40, &58, &58, &60, &7C

.S_DE62
	LDA #19

.S_DE64
	JSR OSWRCH
	TXA
	JMP OSWRCH

	;POLL TRANSMIT
.L_DE6B
	LDA #&32
	JSR OSBYTE
	TXA
	BMI L_DE1F
	BNE TRANSMIT;ERROR, TRY AGAIN?

	RTS


	;1ST USE : REQUEST OS PROCEDURE 2
	;2ND USE : PEEK POINTER & VDU STATUS
	;3RD USE : PEEK SCREEN INFO
	;4TH USE : PEEK SCREEN DATA
.PEEK_BLK
	EQUB &85
	EQUB 0
	EQUW 0
	EQUW PEEK_BLK+12
	EQUW &FFFF
	EQUW PEEK_BLK+12+51;
	EQUW &FFFF
	EQUW 2
	EQUW &FFFF


	;OSWORD &14 BLOCK
	;GET USER'S STATION FROM FILE SERVER
.FS_BLK
	EQUB 0, 30, 0;, 24
	;NOTE THE FOLLOWING BYTE IS 'CLC', I.E. DECIMAL 24 (FUNCTION NO.)


	;ATTEMPT TO READ STATION & NET NUMBERS
	;EXITS WITH C=0 IF READ, A=STATION, X=NET
.S_DEB7
{
	CLC
	LDY #&FF

.L_DEB8
	INY
	LDA (TXTPTR),Y
	EOR #&0D
	BEQ L_DE3F_SYNTAX

	EOR #'-'
	BCS L_DEC6
	BNE L_DEB8

	SEC

.L_DEC6
	BEQ L_DEB8
	
	EOR #&20
	CMP #'A'
	BCS L_DEFD

	LDA #0
	JSR S_DED6
	BCC L_DEFD

	INY

.S_DED6
{
	TAX;X=NET
	LDA #0
	STA &B2

.L_DEDB
	LDA (TXTPTR),Y
	CMP #'@'
	BCS L_DEFA;>=64

	CMP #'.'
	BEQ L_DEFB
	BMI L_DEFA

	AND #&0F
	STA &B3
	ASL &B2
	LDA &B2
	ASL A
	ASL A
	ADC &B2
	ADC &B3
	STA &B2
	INY
	BNE L_DEDB

.L_DEFA
	CLC

.L_DEFB
	LDA &B2
}

.L_DEFD
	RTS
}
}
.VIEW_END

	SAVE "$.VIEW", VIEW_START, VIEW_END

